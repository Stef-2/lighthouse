module;

#include "assimp/Importer.hpp"
#include "assimp/postprocess.h"

export module input_data;

import file_type;
import data_type;
import lighthouse_string;
import geometry;

import std;

export namespace lh
{
	namespace input
	{
		// data generated by reading image files
		struct image_data
		{
			image_data();
			~image_data();

			image_data(const image_data&) = delete;
			image_data& operator=(const image_data&) = delete;
			image_data(image_data&&) noexcept;
			image_data& operator=(image_data&&) noexcept;

			std::byte* m_data;
			std::uint32_t m_width;
			std::uint32_t m_height;
			std::uint8_t m_num_color_channels;
			std::uint32_t m_data_size;
		};

		struct scene_data
		{
			// per mesh data
			// stores indices into the vertex_data_t vector
			// stores bounding boxes
			struct mesh_data
			{
				std::size_t m_vertex_offset;
				std::size_t m_vertex_buffer_size;
				std::size_t m_index_offset;
				std::size_t m_index_buffer_size;

				geometry::transformation_t m_transformation;
				geometry::aabb m_bounding_box;
			};

			struct create_info
			{
				std::int32_t m_importer_postprocess = {
					aiProcess_OptimizeMeshes | aiProcess_OptimizeGraph | aiProcess_GenNormals |
					aiProcess_CalcTangentSpace | aiProcess_GenUVCoords | aiProcess_Triangulate |
					aiProcess_FlipWindingOrder | aiProcess_JoinIdenticalVertices | aiProcess_ImproveCacheLocality |
					aiProcess_LimitBoneWeights | aiProcess_GenBoundingBoxes};
			};

			Assimp::Importer m_importer;

			// vertex and index data packed into a format suitable for device uploading
			data_t m_vertex_data;
			// indices into the data_t vector
			std::vector<struct mesh_data> m_mesh_data;
		};

		auto read_text_file(const std::filesystem::path&) -> string::string_t;
		auto read_binary_file(const std::filesystem::path&) -> lh::data_t;
		auto read_image_file(const std::filesystem::path&) -> const image_data;
		auto read_scene_files(const std::vector<std::filesystem::path>&) -> scene_data;

		export template <file_type type = file_type::text>
		auto read_file(const std::filesystem::path& file_path)
		{
			if constexpr (type == file_type::text) return read_text_file(file_path);

			if constexpr (type == file_type::binary) return read_binary_file(file_path);

			if constexpr (type == file_type::image) return read_image_file(file_path);
		}

		auto assert_path_validity(const std::filesystem::path&, const file_type&) -> bool;
	}
}